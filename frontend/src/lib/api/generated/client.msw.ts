/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Simple Note Application API
 * Public-first API for browsing latest public notes and managing a personal
notebook of plain text notes (for anonymous and regular users). Authentication
is via Firebase ID tokens passed as `Authorization: Bearer <token>`.

## Real-time Features
This API includes WebSocket integration for real-time comment notifications.
When comments are posted, they are automatically broadcasted to all connected
WebSocket clients for live updates.

 * OpenAPI spec version: 1.0.0
 */
import { faker } from "@faker-js/faker";

import { http, HttpResponse } from "msw";

import type {
	AuthResultResponse,
	CommentResponse,
	CommentsListResponse,
	DeleteNoteResponse,
	GetWebSocketConnections200,
	PrivateNoteResponse,
	PrivateNotesListResponse,
	PublicNoteResponse,
	PublicNotesListResponse,
	UserProfileResponse,
	WebsocketConnect200,
	WebsocketDisconnect200,
} from "./schemas";

export const getGetNotesResponseMock = (): PublicNotesListResponse => ({
	status: "success",
	data: {
		notes: [
			{
				id: "550e8400-e29b-41d4-a716-446655440000",
				title: "Hello World",
				content: "This is a simple public note in plain text.\n",
				author: {
					id: "user_ABC123",
					displayName: "Alice",
					avatarUrl: "https://example.com/avatars/alice.png",
				},
				createdAt: "2025-01-01T12:00:00Z",
				updatedAt: "2025-01-02T08:30:00Z",
				publishedAt: "2025-01-02T08:30:00Z",
			},
		],
		pagination: {
			page: 1,
			limit: 12,
			total: 57,
			hasNext: true,
			hasPrev: false,
		},
	},
});

export const getGetNoteByIdResponseMock = (): PublicNoteResponse => ({
	status: "success",
	data: {
		id: "550e8400-e29b-41d4-a716-446655440000",
		title: "Hello World",
		content: "This is a simple public note in plain text.\n",
		author: {
			id: "user_ABC123",
			displayName: "Alice",
			avatarUrl: "https://example.com/avatars/alice.png",
		},
		createdAt: "2025-01-01T12:00:00Z",
		updatedAt: "2025-01-02T08:30:00Z",
		publishedAt: "2025-01-02T08:30:00Z",
	},
});

export const getGetPublicNoteCommentsResponseMock = (
	overrideResponse: Partial<CommentsListResponse> = {},
): CommentsListResponse => ({
	success: faker.datatype.boolean(),
	data: {
		comments: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1,
		).map(() => ({
			id: faker.string.uuid(),
			content: faker.string.alpha({ length: { min: 1, max: 1000 } }),
			username: faker.string.alpha({ length: { min: 10, max: 20 } }),
			createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			postId: faker.string.uuid(),
		})),
		count: faker.number.int({ min: undefined, max: undefined }),
		postId: faker.string.uuid(),
	},
	message: faker.string.alpha({ length: { min: 10, max: 20 } }),
	...overrideResponse,
});

export const getCreatePublicNoteCommentResponseMock = (
	overrideResponse: Partial<CommentResponse> = {},
): CommentResponse => ({
	success: faker.datatype.boolean(),
	data: {
		id: faker.string.uuid(),
		content: faker.string.alpha({ length: { min: 1, max: 1000 } }),
		username: faker.string.alpha({ length: { min: 10, max: 20 } }),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		postId: faker.string.uuid(),
	},
	message: faker.string.alpha({ length: { min: 10, max: 20 } }),
	...overrideResponse,
});

export const getGetMyNotesResponseMock = (
	overrideResponse: Partial<PrivateNotesListResponse> = {},
): PrivateNotesListResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		notes: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1,
		).map(() => ({
			id: faker.string.uuid(),
			title: faker.helpers.arrayElement([
				faker.string.alpha({ length: { min: 10, max: 120 } }),
				null,
			]),
			content: faker.string.alpha({ length: { min: 10, max: 20 } }),
			createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			publishedAt: faker.helpers.arrayElement([
				`${faker.date.past().toISOString().split(".")[0]}Z`,
				null,
			]),
			isPublic: faker.datatype.boolean(),
		})),
		pagination: {
			page: faker.number.int({ min: 1, max: undefined }),
			limit: faker.number.int({ min: 1, max: 100 }),
			total: faker.number.int({ min: 0, max: undefined }),
			hasNext: faker.datatype.boolean(),
			hasPrev: faker.datatype.boolean(),
		},
	},
	...overrideResponse,
});

export const getCreateMyNoteResponseMock = (
	overrideResponse: Partial<PrivateNoteResponse> = {},
): PrivateNoteResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		id: faker.string.uuid(),
		title: faker.helpers.arrayElement([
			faker.string.alpha({ length: { min: 10, max: 120 } }),
			null,
		]),
		content: faker.string.alpha({ length: { min: 10, max: 20 } }),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		publishedAt: faker.helpers.arrayElement([
			`${faker.date.past().toISOString().split(".")[0]}Z`,
			null,
		]),
		isPublic: faker.datatype.boolean(),
	},
	...overrideResponse,
});

export const getGetMyNoteByIdResponseMock = (
	overrideResponse: Partial<PrivateNoteResponse> = {},
): PrivateNoteResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		id: faker.string.uuid(),
		title: faker.helpers.arrayElement([
			faker.string.alpha({ length: { min: 10, max: 120 } }),
			null,
		]),
		content: faker.string.alpha({ length: { min: 10, max: 20 } }),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		publishedAt: faker.helpers.arrayElement([
			`${faker.date.past().toISOString().split(".")[0]}Z`,
			null,
		]),
		isPublic: faker.datatype.boolean(),
	},
	...overrideResponse,
});

export const getUpdateMyNoteResponseMock = (
	overrideResponse: Partial<PrivateNoteResponse> = {},
): PrivateNoteResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		id: faker.string.uuid(),
		title: faker.helpers.arrayElement([
			faker.string.alpha({ length: { min: 10, max: 120 } }),
			null,
		]),
		content: faker.string.alpha({ length: { min: 10, max: 20 } }),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		publishedAt: faker.helpers.arrayElement([
			`${faker.date.past().toISOString().split(".")[0]}Z`,
			null,
		]),
		isPublic: faker.datatype.boolean(),
	},
	...overrideResponse,
});

export const getDeleteMyNoteResponseMock = (
	overrideResponse: Partial<DeleteNoteResponse> = {},
): DeleteNoteResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: { id: faker.string.uuid() },
	...overrideResponse,
});

export const getGetPrivateNoteCommentsResponseMock = (
	overrideResponse: Partial<CommentsListResponse> = {},
): CommentsListResponse => ({
	success: faker.datatype.boolean(),
	data: {
		comments: Array.from(
			{ length: faker.number.int({ min: 1, max: 10 }) },
			(_, i) => i + 1,
		).map(() => ({
			id: faker.string.uuid(),
			content: faker.string.alpha({ length: { min: 1, max: 1000 } }),
			username: faker.string.alpha({ length: { min: 10, max: 20 } }),
			createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			postId: faker.string.uuid(),
		})),
		count: faker.number.int({ min: undefined, max: undefined }),
		postId: faker.string.uuid(),
	},
	message: faker.string.alpha({ length: { min: 10, max: 20 } }),
	...overrideResponse,
});

export const getCreatePrivateNoteCommentResponseMock = (
	overrideResponse: Partial<CommentResponse> = {},
): CommentResponse => ({
	success: faker.datatype.boolean(),
	data: {
		id: faker.string.uuid(),
		content: faker.string.alpha({ length: { min: 1, max: 1000 } }),
		username: faker.string.alpha({ length: { min: 10, max: 20 } }),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		postId: faker.string.uuid(),
	},
	message: faker.string.alpha({ length: { min: 10, max: 20 } }),
	...overrideResponse,
});

export const getPublishNoteResponseMock = (
	overrideResponse: Partial<PrivateNoteResponse> = {},
): PrivateNoteResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		id: faker.string.uuid(),
		title: faker.helpers.arrayElement([
			faker.string.alpha({ length: { min: 10, max: 120 } }),
			null,
		]),
		content: faker.string.alpha({ length: { min: 10, max: 20 } }),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		publishedAt: faker.helpers.arrayElement([
			`${faker.date.past().toISOString().split(".")[0]}Z`,
			null,
		]),
		isPublic: faker.datatype.boolean(),
	},
	...overrideResponse,
});

export const getUnpublishNoteResponseMock = (
	overrideResponse: Partial<PrivateNoteResponse> = {},
): PrivateNoteResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		id: faker.string.uuid(),
		title: faker.helpers.arrayElement([
			faker.string.alpha({ length: { min: 10, max: 120 } }),
			null,
		]),
		content: faker.string.alpha({ length: { min: 10, max: 20 } }),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		publishedAt: faker.helpers.arrayElement([
			`${faker.date.past().toISOString().split(".")[0]}Z`,
			null,
		]),
		isPublic: faker.datatype.boolean(),
	},
	...overrideResponse,
});

export const getWebsocketConnectResponseMock = (
	overrideResponse: Partial<WebsocketConnect200> = {},
): WebsocketConnect200 => ({
	statusCode: faker.number.int({ min: undefined, max: undefined }),
	body: faker.string.alpha({ length: { min: 10, max: 20 } }),
	...overrideResponse,
});

export const getWebsocketDisconnectResponseMock = (
	overrideResponse: Partial<WebsocketDisconnect200> = {},
): WebsocketDisconnect200 => ({
	statusCode: faker.number.int({ min: undefined, max: undefined }),
	body: faker.string.alpha({ length: { min: 10, max: 20 } }),
	...overrideResponse,
});

export const getGetWebSocketConnectionsResponseMock = (
	overrideResponse: Partial<GetWebSocketConnections200> = {},
): GetWebSocketConnections200 => ({
	connectionCount: faker.number.int({ min: undefined, max: undefined }),
	timestamp: `${faker.date.past().toISOString().split(".")[0]}Z`,
	...overrideResponse,
});

export const getGetUserProfileResponseMock = (
	overrideResponse: Partial<UserProfileResponse> = {},
): UserProfileResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		uid: faker.string.alpha({ length: { min: 10, max: 20 } }),
		displayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
		email: faker.helpers.arrayElement([faker.internet.email(), null]),
		avatarUrl: faker.helpers.arrayElement([faker.internet.url(), null]),
		isAnonymous: faker.datatype.boolean(),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
	},
	...overrideResponse,
});

export const getUpdateUserProfileResponseMock = (
	overrideResponse: Partial<UserProfileResponse> = {},
): UserProfileResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		uid: faker.string.alpha({ length: { min: 10, max: 20 } }),
		displayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
		email: faker.helpers.arrayElement([faker.internet.email(), null]),
		avatarUrl: faker.helpers.arrayElement([faker.internet.url(), null]),
		isAnonymous: faker.datatype.boolean(),
		createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
	},
	...overrideResponse,
});

export const getAuthenticateAnonymousResponseMock = (
	overrideResponse: Partial<AuthResultResponse> = {},
): AuthResultResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		user: {
			uid: faker.string.alpha({ length: { min: 10, max: 20 } }),
			displayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
			email: faker.helpers.arrayElement([faker.internet.email(), null]),
			avatarUrl: faker.helpers.arrayElement([faker.internet.url(), null]),
			isAnonymous: faker.datatype.boolean(),
			createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		},
		isAnonymous: faker.datatype.boolean(),
		created: faker.datatype.boolean(),
		wasPromoted: faker.datatype.boolean(),
	},
	...overrideResponse,
});

export const getLoginRegularUserResponseMock = (
	overrideResponse: Partial<AuthResultResponse> = {},
): AuthResultResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		user: {
			uid: faker.string.alpha({ length: { min: 10, max: 20 } }),
			displayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
			email: faker.helpers.arrayElement([faker.internet.email(), null]),
			avatarUrl: faker.helpers.arrayElement([faker.internet.url(), null]),
			isAnonymous: faker.datatype.boolean(),
			createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		},
		isAnonymous: faker.datatype.boolean(),
		created: faker.datatype.boolean(),
		wasPromoted: faker.datatype.boolean(),
	},
	...overrideResponse,
});

export const getPromoteAnonymousUserResponseMock = (
	overrideResponse: Partial<AuthResultResponse> = {},
): AuthResultResponse => ({
	status: faker.helpers.arrayElement(["success"] as const),
	data: {
		user: {
			uid: faker.string.alpha({ length: { min: 10, max: 20 } }),
			displayName: faker.string.alpha({ length: { min: 10, max: 20 } }),
			email: faker.helpers.arrayElement([faker.internet.email(), null]),
			avatarUrl: faker.helpers.arrayElement([faker.internet.url(), null]),
			isAnonymous: faker.datatype.boolean(),
			createdAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
			updatedAt: `${faker.date.past().toISOString().split(".")[0]}Z`,
		},
		isAnonymous: faker.datatype.boolean(),
		created: faker.datatype.boolean(),
		wasPromoted: faker.datatype.boolean(),
	},
	...overrideResponse,
});

export const getGetNotesMockHandler = (
	overrideResponse?:
		| PublicNotesListResponse
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<PublicNotesListResponse> | PublicNotesListResponse),
) => {
	return http.get("*/notes", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getGetNotesResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getGetNoteByIdMockHandler = (
	overrideResponse?:
		| PublicNoteResponse
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<PublicNoteResponse> | PublicNoteResponse),
) => {
	return http.get("*/notes/:id", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getGetNoteByIdResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getGetPublicNoteCommentsMockHandler = (
	overrideResponse?:
		| CommentsListResponse
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<CommentsListResponse> | CommentsListResponse),
) => {
	return http.get("*/notes/:id/comments", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getGetPublicNoteCommentsResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getCreatePublicNoteCommentMockHandler = (
	overrideResponse?:
		| CommentResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<CommentResponse> | CommentResponse),
) => {
	return http.post("*/notes/:id/comments", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getCreatePublicNoteCommentResponseMock(),
			),
			{ status: 201, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getGetMyNotesMockHandler = (
	overrideResponse?:
		| PrivateNotesListResponse
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<PrivateNotesListResponse> | PrivateNotesListResponse),
) => {
	return http.get("*/me/notes", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getGetMyNotesResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getCreateMyNoteMockHandler = (
	overrideResponse?:
		| PrivateNoteResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<PrivateNoteResponse> | PrivateNoteResponse),
) => {
	return http.post("*/me/notes", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getCreateMyNoteResponseMock(),
			),
			{ status: 201, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getGetMyNoteByIdMockHandler = (
	overrideResponse?:
		| PrivateNoteResponse
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<PrivateNoteResponse> | PrivateNoteResponse),
) => {
	return http.get("*/me/notes/:id", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getGetMyNoteByIdResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getUpdateMyNoteMockHandler = (
	overrideResponse?:
		| PrivateNoteResponse
		| ((
				info: Parameters<Parameters<typeof http.patch>[1]>[0],
		  ) => Promise<PrivateNoteResponse> | PrivateNoteResponse),
) => {
	return http.patch("*/me/notes/:id", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getUpdateMyNoteResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getDeleteMyNoteMockHandler = (
	overrideResponse?:
		| DeleteNoteResponse
		| ((
				info: Parameters<Parameters<typeof http.delete>[1]>[0],
		  ) => Promise<DeleteNoteResponse> | DeleteNoteResponse),
) => {
	return http.delete("*/me/notes/:id", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getDeleteMyNoteResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getGetPrivateNoteCommentsMockHandler = (
	overrideResponse?:
		| CommentsListResponse
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<CommentsListResponse> | CommentsListResponse),
) => {
	return http.get("*/me/notes/:id/comments", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getGetPrivateNoteCommentsResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getCreatePrivateNoteCommentMockHandler = (
	overrideResponse?:
		| CommentResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<CommentResponse> | CommentResponse),
) => {
	return http.post("*/me/notes/:id/comments", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getCreatePrivateNoteCommentResponseMock(),
			),
			{ status: 201, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getPublishNoteMockHandler = (
	overrideResponse?:
		| PrivateNoteResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<PrivateNoteResponse> | PrivateNoteResponse),
) => {
	return http.post("*/me/notes/:id/publish", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getPublishNoteResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getUnpublishNoteMockHandler = (
	overrideResponse?:
		| PrivateNoteResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<PrivateNoteResponse> | PrivateNoteResponse),
) => {
	return http.post("*/me/notes/:id/unpublish", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getUnpublishNoteResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getWebsocketConnectMockHandler = (
	overrideResponse?:
		| WebsocketConnect200
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<WebsocketConnect200> | WebsocketConnect200),
) => {
	return http.post("*/websocket/connect", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getWebsocketConnectResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getWebsocketDisconnectMockHandler = (
	overrideResponse?:
		| WebsocketDisconnect200
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<WebsocketDisconnect200> | WebsocketDisconnect200),
) => {
	return http.post("*/websocket/disconnect", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getWebsocketDisconnectResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getGetWebSocketConnectionsMockHandler = (
	overrideResponse?:
		| GetWebSocketConnections200
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<GetWebSocketConnections200> | GetWebSocketConnections200),
) => {
	return http.get("*/websocket/connections", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getGetWebSocketConnectionsResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getGetUserProfileMockHandler = (
	overrideResponse?:
		| UserProfileResponse
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<UserProfileResponse> | UserProfileResponse),
) => {
	return http.get("*/me", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getGetUserProfileResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getUpdateUserProfileMockHandler = (
	overrideResponse?:
		| UserProfileResponse
		| ((
				info: Parameters<Parameters<typeof http.patch>[1]>[0],
		  ) => Promise<UserProfileResponse> | UserProfileResponse),
) => {
	return http.patch("*/me", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getUpdateUserProfileResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getAuthenticateAnonymousMockHandler = (
	overrideResponse?:
		| AuthResultResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<AuthResultResponse> | AuthResultResponse),
) => {
	return http.post("*/auth/anonymous-login", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getAuthenticateAnonymousResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getLoginRegularUserMockHandler = (
	overrideResponse?:
		| AuthResultResponse
		| ((
				info: Parameters<Parameters<typeof http.get>[1]>[0],
		  ) => Promise<AuthResultResponse> | AuthResultResponse),
) => {
	return http.get("*/auth/login", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getLoginRegularUserResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};

export const getPromoteAnonymousUserMockHandler = (
	overrideResponse?:
		| AuthResultResponse
		| ((
				info: Parameters<Parameters<typeof http.post>[1]>[0],
		  ) => Promise<AuthResultResponse> | AuthResultResponse),
) => {
	return http.post("*/auth/anonymous-promote", async (info) => {
		return new HttpResponse(
			JSON.stringify(
				overrideResponse !== undefined
					? typeof overrideResponse === "function"
						? await overrideResponse(info)
						: overrideResponse
					: getPromoteAnonymousUserResponseMock(),
			),
			{ status: 200, headers: { "Content-Type": "application/json" } },
		);
	});
};
export const getSimpleNoteApplicationAPIMock = () => [
	getGetNotesMockHandler(),
	getGetNoteByIdMockHandler(),
	getGetPublicNoteCommentsMockHandler(),
	getCreatePublicNoteCommentMockHandler(),
	getGetMyNotesMockHandler(),
	getCreateMyNoteMockHandler(),
	getGetMyNoteByIdMockHandler(),
	getUpdateMyNoteMockHandler(),
	getDeleteMyNoteMockHandler(),
	getGetPrivateNoteCommentsMockHandler(),
	getCreatePrivateNoteCommentMockHandler(),
	getPublishNoteMockHandler(),
	getUnpublishNoteMockHandler(),
	getWebsocketConnectMockHandler(),
	getWebsocketDisconnectMockHandler(),
	getGetWebSocketConnectionsMockHandler(),
	getGetUserProfileMockHandler(),
	getUpdateUserProfileMockHandler(),
	getAuthenticateAnonymousMockHandler(),
	getLoginRegularUserMockHandler(),
	getPromoteAnonymousUserMockHandler(),
];
