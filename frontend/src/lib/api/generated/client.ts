/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * Simple Note Application API
 * Public-first API for browsing latest public notes and managing a personal
notebook of plain text notes (for anonymous and regular users). Authentication
is via Firebase ID tokens passed as `Authorization: Bearer <token>`.

## Real-time Features
This API includes WebSocket integration for real-time comment notifications.
When comments are posted, they are automatically broadcasted to all connected
WebSocket clients for live updates.

 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
	MutationFunction,
	QueryFunction,
	QueryKey,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
} from "@tanstack/react-query";

import type {
	AnonymousPromoteRequest,
	AuthResultResponse,
	CommentResponse,
	CommentsListResponse,
	CreateMyNoteBody,
	CreatePrivateNoteCommentBody,
	CreatePublicNoteCommentBody,
	DeleteNoteResponse,
	ForbiddenResponse,
	GetMyNotesParams,
	GetNotesParams,
	GetWebSocketConnections200,
	NotFoundResponse,
	PrivateNoteResponse,
	PrivateNotesListResponse,
	PublicNoteResponse,
	PublicNotesListResponse,
	UnauthorizedResponse,
	UpdateMyNoteBody,
	UpdateUserProfileBody,
	UserProfileResponse,
	ValidationErrorResponse,
	WebsocketConnect200,
	WebsocketConnect400,
	WebsocketConnect500,
	WebsocketConnectBody,
	WebsocketDisconnect200,
	WebsocketDisconnect400,
	WebsocketDisconnect500,
	WebsocketDisconnectBody,
} from "./schemas";

import { customFetch } from "../customFetch";

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * @summary List latest public notes
 */
export const getGetNotesUrl = (params?: GetNotesParams) => {
	const normalizedParams = new URLSearchParams();

	for (const [key, value] of Object.entries(params || {})) {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	}

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/notes?${stringifiedParams}`
		: "/notes";
};

export const getNotes = async (
	params?: GetNotesParams,
	options?: RequestInit,
): Promise<PublicNotesListResponse> => {
	return customFetch<PublicNotesListResponse>(getGetNotesUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetNotesQueryKey = (params?: GetNotesParams) => {
	return ["/notes", ...(params ? [params] : [])] as const;
};

export const getGetNotesQueryOptions = <
	TData = Awaited<ReturnType<typeof getNotes>>,
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
>(
	params?: GetNotesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getNotes>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetNotesQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getNotes>>> = ({
		signal,
	}) => getNotes(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getNotes>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetNotesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getNotes>>
>;
export type GetNotesQueryError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| ValidationErrorResponse;

/**
 * @summary List latest public notes
 */

export function useGetNotes<
	TData = Awaited<ReturnType<typeof getNotes>>,
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
>(
	params?: GetNotesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getNotes>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetNotesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get public note by ID
 */
export const getGetNoteByIdUrl = (id: string) => {
	return `/notes/${id}`;
};

export const getNoteById = async (
	id: string,
	options?: RequestInit,
): Promise<PublicNoteResponse> => {
	return customFetch<PublicNoteResponse>(getGetNoteByIdUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetNoteByIdQueryKey = (id?: string) => {
	return [`/notes/${id}`] as const;
};

export const getGetNoteByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getNoteById>>,
	TError = NotFoundResponse | ValidationErrorResponse,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getNoteById>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetNoteByIdQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getNoteById>>> = ({
		signal,
	}) => getNoteById(id, { signal, ...requestOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof getNoteById>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetNoteByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getNoteById>>
>;
export type GetNoteByIdQueryError = NotFoundResponse | ValidationErrorResponse;

/**
 * @summary Get public note by ID
 */

export function useGetNoteById<
	TData = Awaited<ReturnType<typeof getNoteById>>,
	TError = NotFoundResponse | ValidationErrorResponse,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getNoteById>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetNoteByIdQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get comments for a public note
 */
export const getGetPublicNoteCommentsUrl = (id: string) => {
	return `/notes/${id}/comments`;
};

export const getPublicNoteComments = async (
	id: string,
	options?: RequestInit,
): Promise<CommentsListResponse> => {
	return customFetch<CommentsListResponse>(getGetPublicNoteCommentsUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetPublicNoteCommentsQueryKey = (id?: string) => {
	return [`/notes/${id}/comments`] as const;
};

export const getGetPublicNoteCommentsQueryOptions = <
	TData = Awaited<ReturnType<typeof getPublicNoteComments>>,
	TError = NotFoundResponse | ValidationErrorResponse,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getPublicNoteComments>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetPublicNoteCommentsQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getPublicNoteComments>>
	> = ({ signal }) => getPublicNoteComments(id, { signal, ...requestOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof getPublicNoteComments>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetPublicNoteCommentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getPublicNoteComments>>
>;
export type GetPublicNoteCommentsQueryError =
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Get comments for a public note
 */

export function useGetPublicNoteComments<
	TData = Awaited<ReturnType<typeof getPublicNoteComments>>,
	TError = NotFoundResponse | ValidationErrorResponse,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getPublicNoteComments>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetPublicNoteCommentsQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Creates a new comment on a public note. Requires authentication.
Automatically broadcasts the new comment to all connected WebSocket clients.

 * @summary Create a comment on a public note
 */
export const getCreatePublicNoteCommentUrl = (id: string) => {
	return `/notes/${id}/comments`;
};

export const createPublicNoteComment = async (
	id: string,
	createPublicNoteCommentBody: CreatePublicNoteCommentBody,
	options?: RequestInit,
): Promise<CommentResponse> => {
	return customFetch<CommentResponse>(getCreatePublicNoteCommentUrl(id), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createPublicNoteCommentBody),
	});
};

export const getCreatePublicNoteCommentMutationOptions = <
	TError =
		| ValidationErrorResponse
		| UnauthorizedResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createPublicNoteComment>>,
		TError,
		{ id: string; data: CreatePublicNoteCommentBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createPublicNoteComment>>,
	TError,
	{ id: string; data: CreatePublicNoteCommentBody },
	TContext
> => {
	const mutationKey = ["createPublicNoteComment"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createPublicNoteComment>>,
		{ id: string; data: CreatePublicNoteCommentBody }
	> = (props) => {
		const { id, data } = props ?? {};

		return createPublicNoteComment(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreatePublicNoteCommentMutationResult = NonNullable<
	Awaited<ReturnType<typeof createPublicNoteComment>>
>;
export type CreatePublicNoteCommentMutationBody = CreatePublicNoteCommentBody;
export type CreatePublicNoteCommentMutationError =
	| ValidationErrorResponse
	| UnauthorizedResponse
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Create a comment on a public note
 */
export const useCreatePublicNoteComment = <
	TError =
		| ValidationErrorResponse
		| UnauthorizedResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createPublicNoteComment>>,
		TError,
		{ id: string; data: CreatePublicNoteCommentBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof createPublicNoteComment>>,
	TError,
	{ id: string; data: CreatePublicNoteCommentBody },
	TContext
> => {
	const mutationOptions = getCreatePublicNoteCommentMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary List my private notes
 */
export const getGetMyNotesUrl = (params?: GetMyNotesParams) => {
	const normalizedParams = new URLSearchParams();

	for (const [key, value] of Object.entries(params || {})) {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	}

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `/me/notes?${stringifiedParams}`
		: "/me/notes";
};

export const getMyNotes = async (
	params?: GetMyNotesParams,
	options?: RequestInit,
): Promise<PrivateNotesListResponse> => {
	return customFetch<PrivateNotesListResponse>(getGetMyNotesUrl(params), {
		...options,
		method: "GET",
	});
};

export const getGetMyNotesQueryKey = (params?: GetMyNotesParams) => {
	return ["/me/notes", ...(params ? [params] : [])] as const;
};

export const getGetMyNotesQueryOptions = <
	TData = Awaited<ReturnType<typeof getMyNotes>>,
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
>(
	params?: GetMyNotesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getMyNotes>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetMyNotesQueryKey(params);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyNotes>>> = ({
		signal,
	}) => getMyNotes(params, { signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getMyNotes>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetMyNotesQueryResult = NonNullable<
	Awaited<ReturnType<typeof getMyNotes>>
>;
export type GetMyNotesQueryError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| ValidationErrorResponse;

/**
 * @summary List my private notes
 */

export function useGetMyNotes<
	TData = Awaited<ReturnType<typeof getMyNotes>>,
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
>(
	params?: GetMyNotesParams,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getMyNotes>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetMyNotesQueryOptions(params, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Create a new private note
 */
export const getCreateMyNoteUrl = () => {
	return "/me/notes";
};

export const createMyNote = async (
	createMyNoteBody: CreateMyNoteBody,
	options?: RequestInit,
): Promise<PrivateNoteResponse> => {
	return customFetch<PrivateNoteResponse>(getCreateMyNoteUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createMyNoteBody),
	});
};

export const getCreateMyNoteMutationOptions = <
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createMyNote>>,
		TError,
		{ data: CreateMyNoteBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createMyNote>>,
	TError,
	{ data: CreateMyNoteBody },
	TContext
> => {
	const mutationKey = ["createMyNote"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createMyNote>>,
		{ data: CreateMyNoteBody }
	> = (props) => {
		const { data } = props ?? {};

		return createMyNote(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateMyNoteMutationResult = NonNullable<
	Awaited<ReturnType<typeof createMyNote>>
>;
export type CreateMyNoteMutationBody = CreateMyNoteBody;
export type CreateMyNoteMutationError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| ValidationErrorResponse;

/**
 * @summary Create a new private note
 */
export const useCreateMyNote = <
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createMyNote>>,
		TError,
		{ data: CreateMyNoteBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof createMyNote>>,
	TError,
	{ data: CreateMyNoteBody },
	TContext
> => {
	const mutationOptions = getCreateMyNoteMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Get my private note by ID
 */
export const getGetMyNoteByIdUrl = (id: string) => {
	return `/me/notes/${id}`;
};

export const getMyNoteById = async (
	id: string,
	options?: RequestInit,
): Promise<PrivateNoteResponse> => {
	return customFetch<PrivateNoteResponse>(getGetMyNoteByIdUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetMyNoteByIdQueryKey = (id?: string) => {
	return [`/me/notes/${id}`] as const;
};

export const getGetMyNoteByIdQueryOptions = <
	TData = Awaited<ReturnType<typeof getMyNoteById>>,
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getMyNoteById>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetMyNoteByIdQueryKey(id);

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getMyNoteById>>> = ({
		signal,
	}) => getMyNoteById(id, { signal, ...requestOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof getMyNoteById>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetMyNoteByIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof getMyNoteById>>
>;
export type GetMyNoteByIdQueryError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Get my private note by ID
 */

export function useGetMyNoteById<
	TData = Awaited<ReturnType<typeof getMyNoteById>>,
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getMyNoteById>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetMyNoteByIdQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update my private note
 */
export const getUpdateMyNoteUrl = (id: string) => {
	return `/me/notes/${id}`;
};

export const updateMyNote = async (
	id: string,
	updateMyNoteBody: UpdateMyNoteBody,
	options?: RequestInit,
): Promise<PrivateNoteResponse> => {
	return customFetch<PrivateNoteResponse>(getUpdateMyNoteUrl(id), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateMyNoteBody),
	});
};

export const getUpdateMyNoteMutationOptions = <
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateMyNote>>,
		TError,
		{ id: string; data: UpdateMyNoteBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateMyNote>>,
	TError,
	{ id: string; data: UpdateMyNoteBody },
	TContext
> => {
	const mutationKey = ["updateMyNote"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateMyNote>>,
		{ id: string; data: UpdateMyNoteBody }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateMyNote(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateMyNoteMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateMyNote>>
>;
export type UpdateMyNoteMutationBody = UpdateMyNoteBody;
export type UpdateMyNoteMutationError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Update my private note
 */
export const useUpdateMyNote = <
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateMyNote>>,
		TError,
		{ id: string; data: UpdateMyNoteBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateMyNote>>,
	TError,
	{ id: string; data: UpdateMyNoteBody },
	TContext
> => {
	const mutationOptions = getUpdateMyNoteMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Delete my private note
 */
export const getDeleteMyNoteUrl = (id: string) => {
	return `/me/notes/${id}`;
};

export const deleteMyNote = async (
	id: string,
	options?: RequestInit,
): Promise<DeleteNoteResponse> => {
	return customFetch<DeleteNoteResponse>(getDeleteMyNoteUrl(id), {
		...options,
		method: "DELETE",
	});
};

export const getDeleteMyNoteMutationOptions = <
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteMyNote>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteMyNote>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["deleteMyNote"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteMyNote>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return deleteMyNote(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteMyNoteMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteMyNote>>
>;

export type DeleteMyNoteMutationError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Delete my private note
 */
export const useDeleteMyNote = <
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteMyNote>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteMyNote>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getDeleteMyNoteMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Get comments for my private note
 */
export const getGetPrivateNoteCommentsUrl = (id: string) => {
	return `/me/notes/${id}/comments`;
};

export const getPrivateNoteComments = async (
	id: string,
	options?: RequestInit,
): Promise<CommentsListResponse> => {
	return customFetch<CommentsListResponse>(getGetPrivateNoteCommentsUrl(id), {
		...options,
		method: "GET",
	});
};

export const getGetPrivateNoteCommentsQueryKey = (id?: string) => {
	return [`/me/notes/${id}/comments`] as const;
};

export const getGetPrivateNoteCommentsQueryOptions = <
	TData = Awaited<ReturnType<typeof getPrivateNoteComments>>,
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getPrivateNoteComments>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetPrivateNoteCommentsQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getPrivateNoteComments>>
	> = ({ signal }) => getPrivateNoteComments(id, { signal, ...requestOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof getPrivateNoteComments>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetPrivateNoteCommentsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getPrivateNoteComments>>
>;
export type GetPrivateNoteCommentsQueryError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Get comments for my private note
 */

export function useGetPrivateNoteComments<
	TData = Awaited<ReturnType<typeof getPrivateNoteComments>>,
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
>(
	id: string,
	options?: {
		query?: UseQueryOptions<
			Awaited<ReturnType<typeof getPrivateNoteComments>>,
			TError,
			TData
		>;
		request?: SecondParameter<typeof customFetch>;
	},
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetPrivateNoteCommentsQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Creates a new comment on a private note owned by the authenticated user.
Automatically broadcasts the new comment to all connected WebSocket clients.

 * @summary Create a comment on my private note
 */
export const getCreatePrivateNoteCommentUrl = (id: string) => {
	return `/me/notes/${id}/comments`;
};

export const createPrivateNoteComment = async (
	id: string,
	createPrivateNoteCommentBody: CreatePrivateNoteCommentBody,
	options?: RequestInit,
): Promise<CommentResponse> => {
	return customFetch<CommentResponse>(getCreatePrivateNoteCommentUrl(id), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createPrivateNoteCommentBody),
	});
};

export const getCreatePrivateNoteCommentMutationOptions = <
	TError =
		| ValidationErrorResponse
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createPrivateNoteComment>>,
		TError,
		{ id: string; data: CreatePrivateNoteCommentBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createPrivateNoteComment>>,
	TError,
	{ id: string; data: CreatePrivateNoteCommentBody },
	TContext
> => {
	const mutationKey = ["createPrivateNoteComment"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createPrivateNoteComment>>,
		{ id: string; data: CreatePrivateNoteCommentBody }
	> = (props) => {
		const { id, data } = props ?? {};

		return createPrivateNoteComment(id, data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreatePrivateNoteCommentMutationResult = NonNullable<
	Awaited<ReturnType<typeof createPrivateNoteComment>>
>;
export type CreatePrivateNoteCommentMutationBody = CreatePrivateNoteCommentBody;
export type CreatePrivateNoteCommentMutationError =
	| ValidationErrorResponse
	| UnauthorizedResponse
	| ForbiddenResponse
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Create a comment on my private note
 */
export const useCreatePrivateNoteComment = <
	TError =
		| ValidationErrorResponse
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createPrivateNoteComment>>,
		TError,
		{ id: string; data: CreatePrivateNoteCommentBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof createPrivateNoteComment>>,
	TError,
	{ id: string; data: CreatePrivateNoteCommentBody },
	TContext
> => {
	const mutationOptions = getCreatePrivateNoteCommentMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Make note public (publish)
 */
export const getPublishNoteUrl = (id: string) => {
	return `/me/notes/${id}/publish`;
};

export const publishNote = async (
	id: string,
	options?: RequestInit,
): Promise<PrivateNoteResponse> => {
	return customFetch<PrivateNoteResponse>(getPublishNoteUrl(id), {
		...options,
		method: "POST",
	});
};

export const getPublishNoteMutationOptions = <
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof publishNote>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof publishNote>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["publishNote"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof publishNote>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return publishNote(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PublishNoteMutationResult = NonNullable<
	Awaited<ReturnType<typeof publishNote>>
>;

export type PublishNoteMutationError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Make note public (publish)
 */
export const usePublishNote = <
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof publishNote>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof publishNote>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getPublishNoteMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Make note private (unpublish)
 */
export const getUnpublishNoteUrl = (id: string) => {
	return `/me/notes/${id}/unpublish`;
};

export const unpublishNote = async (
	id: string,
	options?: RequestInit,
): Promise<PrivateNoteResponse> => {
	return customFetch<PrivateNoteResponse>(getUnpublishNoteUrl(id), {
		...options,
		method: "POST",
	});
};

export const getUnpublishNoteMutationOptions = <
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof unpublishNote>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof unpublishNote>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["unpublishNote"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof unpublishNote>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return unpublishNote(id, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UnpublishNoteMutationResult = NonNullable<
	Awaited<ReturnType<typeof unpublishNote>>
>;

export type UnpublishNoteMutationError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| NotFoundResponse
	| ValidationErrorResponse;

/**
 * @summary Make note private (unpublish)
 */
export const useUnpublishNote = <
	TError =
		| UnauthorizedResponse
		| ForbiddenResponse
		| NotFoundResponse
		| ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof unpublishNote>>,
		TError,
		{ id: string },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof unpublishNote>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions = getUnpublishNoteMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * Internal endpoint for handling WebSocket connection events.
This endpoint is triggered automatically by the WebSocket infrastructure
when clients establish connections.

 * @summary WebSocket connection handler
 */
export const getWebsocketConnectUrl = () => {
	return "/websocket/connect";
};

export const websocketConnect = async (
	websocketConnectBody: WebsocketConnectBody,
	options?: RequestInit,
): Promise<WebsocketConnect200> => {
	return customFetch<WebsocketConnect200>(getWebsocketConnectUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(websocketConnectBody),
	});
};

export const getWebsocketConnectMutationOptions = <
	TError = WebsocketConnect400 | WebsocketConnect500,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof websocketConnect>>,
		TError,
		{ data: WebsocketConnectBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof websocketConnect>>,
	TError,
	{ data: WebsocketConnectBody },
	TContext
> => {
	const mutationKey = ["websocketConnect"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof websocketConnect>>,
		{ data: WebsocketConnectBody }
	> = (props) => {
		const { data } = props ?? {};

		return websocketConnect(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WebsocketConnectMutationResult = NonNullable<
	Awaited<ReturnType<typeof websocketConnect>>
>;
export type WebsocketConnectMutationBody = WebsocketConnectBody;
export type WebsocketConnectMutationError =
	| WebsocketConnect400
	| WebsocketConnect500;

/**
 * @summary WebSocket connection handler
 */
export const useWebsocketConnect = <
	TError = WebsocketConnect400 | WebsocketConnect500,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof websocketConnect>>,
		TError,
		{ data: WebsocketConnectBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof websocketConnect>>,
	TError,
	{ data: WebsocketConnectBody },
	TContext
> => {
	const mutationOptions = getWebsocketConnectMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * Internal endpoint for handling WebSocket disconnection events.
This endpoint is triggered automatically by the WebSocket infrastructure
when clients disconnect.

 * @summary WebSocket disconnection handler
 */
export const getWebsocketDisconnectUrl = () => {
	return "/websocket/disconnect";
};

export const websocketDisconnect = async (
	websocketDisconnectBody: WebsocketDisconnectBody,
	options?: RequestInit,
): Promise<WebsocketDisconnect200> => {
	return customFetch<WebsocketDisconnect200>(getWebsocketDisconnectUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(websocketDisconnectBody),
	});
};

export const getWebsocketDisconnectMutationOptions = <
	TError = WebsocketDisconnect400 | WebsocketDisconnect500,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof websocketDisconnect>>,
		TError,
		{ data: WebsocketDisconnectBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof websocketDisconnect>>,
	TError,
	{ data: WebsocketDisconnectBody },
	TContext
> => {
	const mutationKey = ["websocketDisconnect"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof websocketDisconnect>>,
		{ data: WebsocketDisconnectBody }
	> = (props) => {
		const { data } = props ?? {};

		return websocketDisconnect(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type WebsocketDisconnectMutationResult = NonNullable<
	Awaited<ReturnType<typeof websocketDisconnect>>
>;
export type WebsocketDisconnectMutationBody = WebsocketDisconnectBody;
export type WebsocketDisconnectMutationError =
	| WebsocketDisconnect400
	| WebsocketDisconnect500;

/**
 * @summary WebSocket disconnection handler
 */
export const useWebsocketDisconnect = <
	TError = WebsocketDisconnect400 | WebsocketDisconnect500,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof websocketDisconnect>>,
		TError,
		{ data: WebsocketDisconnectBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof websocketDisconnect>>,
	TError,
	{ data: WebsocketDisconnectBody },
	TContext
> => {
	const mutationOptions = getWebsocketDisconnectMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * Health check endpoint that returns the current number of active
WebSocket connections. Used for monitoring and debugging.

 * @summary Get WebSocket connection count
 */
export const getGetWebSocketConnectionsUrl = () => {
	return "/websocket/connections";
};

export const getWebSocketConnections = async (
	options?: RequestInit,
): Promise<GetWebSocketConnections200> => {
	return customFetch<GetWebSocketConnections200>(
		getGetWebSocketConnectionsUrl(),
		{
			...options,
			method: "GET",
		},
	);
};

export const getGetWebSocketConnectionsQueryKey = () => {
	return ["/websocket/connections"] as const;
};

export const getGetWebSocketConnectionsQueryOptions = <
	TData = Awaited<ReturnType<typeof getWebSocketConnections>>,
	TError = UnauthorizedResponse | null,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof getWebSocketConnections>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customFetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGetWebSocketConnectionsQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof getWebSocketConnections>>
	> = ({ signal }) => getWebSocketConnections({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getWebSocketConnections>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetWebSocketConnectionsQueryResult = NonNullable<
	Awaited<ReturnType<typeof getWebSocketConnections>>
>;
export type GetWebSocketConnectionsQueryError = UnauthorizedResponse | null;

/**
 * @summary Get WebSocket connection count
 */

export function useGetWebSocketConnections<
	TData = Awaited<ReturnType<typeof getWebSocketConnections>>,
	TError = UnauthorizedResponse | null,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof getWebSocketConnections>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetWebSocketConnectionsQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Get user profile
 */
export const getGetUserProfileUrl = () => {
	return "/me";
};

export const getUserProfile = async (
	options?: RequestInit,
): Promise<UserProfileResponse> => {
	return customFetch<UserProfileResponse>(getGetUserProfileUrl(), {
		...options,
		method: "GET",
	});
};

export const getGetUserProfileQueryKey = () => {
	return ["/me"] as const;
};

export const getGetUserProfileQueryOptions = <
	TData = Awaited<ReturnType<typeof getUserProfile>>,
	TError = UnauthorizedResponse | ForbiddenResponse,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof getUserProfile>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customFetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetUserProfileQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof getUserProfile>>> = ({
		signal,
	}) => getUserProfile({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof getUserProfile>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type GetUserProfileQueryResult = NonNullable<
	Awaited<ReturnType<typeof getUserProfile>>
>;
export type GetUserProfileQueryError = UnauthorizedResponse | ForbiddenResponse;

/**
 * @summary Get user profile
 */

export function useGetUserProfile<
	TData = Awaited<ReturnType<typeof getUserProfile>>,
	TError = UnauthorizedResponse | ForbiddenResponse,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof getUserProfile>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getGetUserProfileQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Update user profile
 */
export const getUpdateUserProfileUrl = () => {
	return "/me";
};

export const updateUserProfile = async (
	updateUserProfileBody: UpdateUserProfileBody,
	options?: RequestInit,
): Promise<UserProfileResponse> => {
	return customFetch<UserProfileResponse>(getUpdateUserProfileUrl(), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateUserProfileBody),
	});
};

export const getUpdateUserProfileMutationOptions = <
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateUserProfile>>,
		TError,
		{ data: UpdateUserProfileBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateUserProfile>>,
	TError,
	{ data: UpdateUserProfileBody },
	TContext
> => {
	const mutationKey = ["updateUserProfile"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateUserProfile>>,
		{ data: UpdateUserProfileBody }
	> = (props) => {
		const { data } = props ?? {};

		return updateUserProfile(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateUserProfileMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateUserProfile>>
>;
export type UpdateUserProfileMutationBody = UpdateUserProfileBody;
export type UpdateUserProfileMutationError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| ValidationErrorResponse;

/**
 * @summary Update user profile
 */
export const useUpdateUserProfile = <
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateUserProfile>>,
		TError,
		{ data: UpdateUserProfileBody },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateUserProfile>>,
	TError,
	{ data: UpdateUserProfileBody },
	TContext
> => {
	const mutationOptions = getUpdateUserProfileMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Authenticate anonymous user (validate Firebase anonymous token)
 */
export const getAuthenticateAnonymousUrl = () => {
	return "/auth/anonymous-login";
};

export const authenticateAnonymous = async (
	options?: RequestInit,
): Promise<AuthResultResponse> => {
	return customFetch<AuthResultResponse>(getAuthenticateAnonymousUrl(), {
		...options,
		method: "POST",
	});
};

export const getAuthenticateAnonymousMutationOptions = <
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof authenticateAnonymous>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof authenticateAnonymous>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ["authenticateAnonymous"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof authenticateAnonymous>>,
		void
	> = () => {
		return authenticateAnonymous(requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AuthenticateAnonymousMutationResult = NonNullable<
	Awaited<ReturnType<typeof authenticateAnonymous>>
>;

export type AuthenticateAnonymousMutationError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| ValidationErrorResponse;

/**
 * @summary Authenticate anonymous user (validate Firebase anonymous token)
 */
export const useAuthenticateAnonymous = <
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof authenticateAnonymous>>,
		TError,
		void,
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof authenticateAnonymous>>,
	TError,
	void,
	TContext
> => {
	const mutationOptions = getAuthenticateAnonymousMutationOptions(options);

	return useMutation(mutationOptions);
};

/**
 * @summary Authenticate regular user (validate Firebase token; may insert user)
 */
export const getLoginRegularUserUrl = () => {
	return "/auth/login";
};

export const loginRegularUser = async (
	options?: RequestInit,
): Promise<AuthResultResponse> => {
	return customFetch<AuthResultResponse>(getLoginRegularUserUrl(), {
		...options,
		method: "GET",
	});
};

export const getLoginRegularUserQueryKey = () => {
	return ["/auth/login"] as const;
};

export const getLoginRegularUserQueryOptions = <
	TData = Awaited<ReturnType<typeof loginRegularUser>>,
	TError = UnauthorizedResponse | ForbiddenResponse,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof loginRegularUser>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customFetch>;
}) => {
	const { query: queryOptions, request: requestOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getLoginRegularUserQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof loginRegularUser>>
	> = ({ signal }) => loginRegularUser({ signal, ...requestOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof loginRegularUser>>,
		TError,
		TData
	> & { queryKey: QueryKey };
};

export type LoginRegularUserQueryResult = NonNullable<
	Awaited<ReturnType<typeof loginRegularUser>>
>;
export type LoginRegularUserQueryError =
	| UnauthorizedResponse
	| ForbiddenResponse;

/**
 * @summary Authenticate regular user (validate Firebase token; may insert user)
 */

export function useLoginRegularUser<
	TData = Awaited<ReturnType<typeof loginRegularUser>>,
	TError = UnauthorizedResponse | ForbiddenResponse,
>(options?: {
	query?: UseQueryOptions<
		Awaited<ReturnType<typeof loginRegularUser>>,
		TError,
		TData
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
	const queryOptions = getLoginRegularUserQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: QueryKey;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Promote anonymous user to regular account
 */
export const getPromoteAnonymousUserUrl = () => {
	return "/auth/anonymous-promote";
};

export const promoteAnonymousUser = async (
	anonymousPromoteRequest: AnonymousPromoteRequest,
	options?: RequestInit,
): Promise<AuthResultResponse> => {
	return customFetch<AuthResultResponse>(getPromoteAnonymousUserUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(anonymousPromoteRequest),
	});
};

export const getPromoteAnonymousUserMutationOptions = <
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof promoteAnonymousUser>>,
		TError,
		{ data: AnonymousPromoteRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationOptions<
	Awaited<ReturnType<typeof promoteAnonymousUser>>,
	TError,
	{ data: AnonymousPromoteRequest },
	TContext
> => {
	const mutationKey = ["promoteAnonymousUser"];
	const { mutation: mutationOptions, request: requestOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, request: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof promoteAnonymousUser>>,
		{ data: AnonymousPromoteRequest }
	> = (props) => {
		const { data } = props ?? {};

		return promoteAnonymousUser(data, requestOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PromoteAnonymousUserMutationResult = NonNullable<
	Awaited<ReturnType<typeof promoteAnonymousUser>>
>;
export type PromoteAnonymousUserMutationBody = AnonymousPromoteRequest;
export type PromoteAnonymousUserMutationError =
	| UnauthorizedResponse
	| ForbiddenResponse
	| ValidationErrorResponse;

/**
 * @summary Promote anonymous user to regular account
 */
export const usePromoteAnonymousUser = <
	TError = UnauthorizedResponse | ForbiddenResponse | ValidationErrorResponse,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof promoteAnonymousUser>>,
		TError,
		{ data: AnonymousPromoteRequest },
		TContext
	>;
	request?: SecondParameter<typeof customFetch>;
}): UseMutationResult<
	Awaited<ReturnType<typeof promoteAnonymousUser>>,
	TError,
	{ data: AnonymousPromoteRequest },
	TContext
> => {
	const mutationOptions = getPromoteAnonymousUserMutationOptions(options);

	return useMutation(mutationOptions);
};
